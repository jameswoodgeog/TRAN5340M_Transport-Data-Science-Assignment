---
title: "Using circuity analysis to explore pedestrian access to healthcare services in York"
# Set the formatting options
format:
  pdf:
    pdf-engine: xelatex
# Include a Table Of Contents
    toc: true
# Include a List Of Figures
    lof: true
# Include a List Of Tables
    lot: true
# Number each headed section
    number-sections: true
# Set the main font size and font
    fontsize: 11pt
    mainfont: Calibri
# Adjust the borders to decrease or increase the useable page space
    geometry:
      - top = 15mm
      - bottom = 20mm
      - left = 20mm
      - right = 20mm
# Adjust the headers and footers
    header-includes:
# Set the packages to be used by LaTex
      - \usepackage{placeins}
      - \usepackage{fancyhdr}
      - \usepackage{lastpage}
#  Set the style and what goes in the header and footer of the main and all other pages.
      - \pagestyle{fancy}
      - \thispagestyle{fancy}
      - \fancyhead[R]{Student ID| 201578497}
      - \fancyhead[L]{TRAN5340M | Transport Data Science}
      - \renewcommand{\headrulewidth}{0.02pt}
      - \fancypagestyle{plain}{\fancyhead[R]{Student ID| 201578497}\fancyhead[L]{TRAN5340M | Transport Data Science}\fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}}
# Set the page number to be "Page n of np"
      - \fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}

# CSL and bibliography file to be used
bibliography: tds_refs.bib
csl: "UoL_Harvard.csl"
---

```{=html}
<style>
figcaption {
    text-align: center;
}
</style>
```
```{r, echo=FALSE, eval=FALSE, include=FALSE}
assign("has_internet_via_proxy", TRUE, environment(curl::has_internet))
```

```{r, echo=FALSE, eval=TRUE, include=FALSE}
library(gh)
library(sys)
library(opentripplanner)
library(dodgr)
library(sf)
library(osmdata)
library(dplyr)
library(ggplot2)
library(ggspatial)
library(tmap)
library(tmaptools)
library(OpenStreetMap)
library(units)
library(geodist)
library(tidyr)
library(mapview)
library(leaflet)
library(leaflet.providers)
library(basemaps)
library(kableExtra)
library(gridExtra)
library(knitr)
```

# Introduction

Carlos Moreno first proposed the 15-minute city concept in 2016. The focus of the concept is that access to essential services and amenities, such as healthcare and greenspace should be within a 15-minute walk or cycle from a persons home [@morenoIntroducing15MinuteCity2021]. The COVID-19 pandemic then highlighted the importance of local access to essential services, because lockdowns and other restrictions on movement limited the ability to travel beyond ones immediate neighbourhood. The 15-minute city concept has gained traction more recently within the disciplines of urban planning and sustainable development. It also provided a new perspective on "chrono-urbanism", in which there is an inversely proportional relationship between peoples quality of life and the time people invest in transportation and is especially true in the use of motor vehicles [@loganXminuteCityMeasuring2022].

Active travel modes such as walking and cycling health outcomes for people. It enables better potential fitness levels and reduces inactivity. Benefits to the economy can be measured through a healthier society, which results in fewer people needing to use the NHS, therefore saving it money. The environment benefits from active travel because these modes of are emission-free, which reduces airborne particulate matter, increasing air quality in towns and cities [@SecondCyclingWalking2023].

However, time and its availability is an important factor when it comes to peoples decisions around mode choice. The study by @ralphItReallyToo2020 highlights this very well, and is pertinent to the study in this report because it was discovered that people were more likely to overestimate the length of the route, and therefore the time it would take to walk/cycle, along routes where there were barriers to overcome and many turns to take. This decreased the chance of people using an active mode of transport over motorised vehicles. Other reasons for choosing against walking in their study were fears of crime, getting lost, and carrying something heavy. They also found that people were more likely to lower their estimations of the time and distance of a route with experience and familiarity of a route.

Through urban design and service planning, it should be possible to increase active travel, and reduce (private) motorised vehicle use. In order to achieve these goals, understanding the current situation in terms of accessibility is important. This study looks to contribute to this understanding, using the City of York Local Authority District (York LAD), which includes the City of York and the surrounding villages and by analysing peoples access to essential services (healthcare provision in this case), though circuity of walking route measurements.

# Scope

The primary aim of this study is to analyse ease of pedestrian access to basic essential (health) services. This will highlight the the areas in which access is more or less likely to occur by active travel modes and could help towards future policy in urban design that has a focus on economic and environmental sustainability as well as population health.

Access will be measured through defining a reasonable travel time from each service, based on 20 minutes average walking distance. Twenty minutes was chosen, because the average distance walked in around this amount of time is equivalent to one mile [@britishheartfoundationWalksTreksFAQs].

In this report, I will firstly describe the methods that will be used, and justify some of the decisions made in regards to the preparation, cleaning and processing of the data, including communicating and visualising the results. I will then comment on how these results may contribute to planning the urban environment in respect of the tenets of the 15-minute city. Finally, I will highlight some of the problems and limitations of the study, and propose any changes that could be made to similar studies in the future.

# Area of study

The York LAD was chosen because the of the physical makeup of the city. It sits in the county of North Yorkshire & The Humber, and has a population of around 200,000, of which there is a large student population of around 48,000 [@cityofyorkcouncilOneCityAll], many of which could potentially benefit from cheap and healthy transport options around the city, especially as the main campus of the University of York sits some way outside the centre. Buildings are tightly packed within the walled old center, which is immediately surrounded by decreasingly dense suburban neighbourhoods, and at the periphery by smaller more isolated villages, such as Haxby and Bishopthorpe. This study area should provide a variety of different urban/suburban settings in which analysis can be carried out and compared.

## Spatial Scale

The spatial scale for analysis was based upon the smallest or lowest level of geographical area. This is the Output Area (OA), and typically represents between 40-250 households and is made up of around 100-625 people [@officefornationalstatisticsAreaTypeOffice].

# Datasets

-   The data was extracted, processed and analysed using RStudio 2023.12.1+402 "Ocean Storm".

-   The study area boundary was extracted from the Open Geography Portal [@officefornationalstatisticsOpenGeographyPortal2023].

-   Point data for the healthcare services was extracted from OpenStreetMap (OSM) using the `osmdata`, and the services chosen were `"clinic", "dentist", "doctors", "hospital", "pharmacy"`.

-   A graph of the study area was locally built using the `opentripplanner` package which is a multi-modal route planner, using imported OSM networks and allowed for both the isochrones around the services, and routes to them to be calculated.

# Pre-Processing, Understanding & Preparation

Once the data was extracted, and in order to be able to process them correctly, it was important to understand their structures and content. The OSM data returned points and polygons. So that we were able to calculate isochrones properly from point data, it was necessary to convert polygons consisting of larger buildings such as hospitals, to points representing the centroid of the polygons. This was done using the `st_intersects` and `st_centroid` functions. It was then possible to combine the data that was originally point data and the new centroid points ready for processing. In addition to these conversion processes, any unwanted data was removed from the datasets to make navigation and further processing easier and more efficient.

```{r, echo=FALSE, eval=FALSE, include=FALSE, message=FALSE}
# Load the York Local Authority District shapefile which represents the study area.
# Use this polygon to clip the rest of the data to.
y_lad  <-  st_read("Data/York_LAD.shp")
y_lad <- st_as_sf(y_lad)
```

```{r, echo=FALSE, eval=FALSE, include=FALSE, message=FALSE}
saveRDS(y_lad, "Data/y_lad.RDS")
```

```{r, echo=FALSE, eval=FALSE, include=FALSE}
# This block is commented because the graph that is built here is packaged up and hosted on gitHub.

# # OpenTripPlanner Server setup
# #  SPecify the path to OTP
# path_data <- file.path("Data/OTP")
# 
# # Get the OTP JAR file
# path_otp <- otp_dl_jar(path_data, cache = FALSE)
# 
# # Build the graph
# log1 <- otp_build_graph(otp = path_otp,
#                         dir = path_data,
#                         memory = 6000)
```

```{r, echo=FALSE, include=FALSE, eval=FALSE}
# Load the Graph from github so it does not need to be built from scratch
system("gh release download v0 --repo jameswoodgeog/TRAN5340M_Transport-Data-Science")
# Unzip the downloaded file to "Data/OTP"
unzip("OTP.zip", exdir = "Data/")
```

```{r, echo=FALSE, eval=FALSE, warning=FALSE, include=FALSE}
# Prepare the graph for use on this machine
path_data <- file.path("Data/OTP")
# Get the OTP JAR file
path_otp <- otp_dl_jar(path_data, cache = FALSE)
log2 <- otp_setup(otp = path_otp, dir = path_data, open_browser = FALSE)
```

```{r, echo=FALSE, eval=FALSE, warning=FALSE, include=FALSE}
# Connect this session on RStudio to the OTP server
# You should get something like: -
# Router http://localhost:8080/otp/routers/default exists
otpcon <- otp_connect(timezone = "Europe/London")
```

```{r, echo=FALSE, include=FALSE, eval=FALSE}
# Define the list of healthcare amenities we wishe to analyse
hcare_vars <- c("clinic", "dentist", "doctors", "hospital", "pharmacy")
```

```{r, echo=FALSE, eval=FALSE, include=FALSE}
# Convert the Local Authority boundary polygon to an sf object
y_lad_sf <- st_as_sf(y_lad)
# convert the CRS to match the OSM CRS (4326)
y_lad_sf <- st_transform(y_lad_sf, 4326)
# Save the LAD file as RDS
saveRDS(y_lad_sf, "y_lad_sf.RDS")
```

```{r, echo=FALSE, include=FALSE, eval=FALSE}
y_lad_sf <- readRDS("Data/y_lad_sf.RDS")
```

```{r, echo=FALSE, include=FALSE, eval=FALSE}
# Get the healthcare points/polygons data for the study area
# Create the Overpass API query (q1) using the bounding box based on the York LA boundary
hcare_query <- opq(bbox = st_bbox(y_lad_sf)) |>
# ...for all the highways features from within the specified area
    add_osm_feature(key = "amenity", value = hcare_vars)

# Get all the OSM data
yrk_hcare <- osmdata_sf(hcare_query)
# Save the downloaded data...
saveRDS(yrk_hcare, file = "Data/yrk_hcare.RDS")
```

```{r, include=FALSE, echo=FALSE, eval=FALSE}
# Load the saved data that has previously been downloaded
yrk_hcare <- readRDS("Data/yrk_hcare.RDS")
```

```{r, echo=FALSE, include=FALSE, eval=FALSE}

# tmap_mode("view")
# qtm(yrk_hcare$osm_points) +
#   qtm(yrk_hcare$osm_polygons) +
#   qtm(yrk_hcare$osm_multipolygons)
# tmap_mode("plot")

########### HEALTHCARE
####### POINTS
# Find which points intersect with the polygons. This creates a dataframe that contains a count
int1 <- st_intersects(yrk_hcare$osm_points, yrk_hcare$osm_polygons)

# Take the count data and return T or F if the number of intersections is == 0
int1_bool <- lapply(int1, length)==0

# Use the T or F data to find the points that are to be kept.
hcare_points <- yrk_hcare$osm_points[int1_bool,]
remove(int1)

# tmap_mode("view")
# qtm(hcare_points)
# tmap_mode("plot")
# Now the points have been filtered out to leave only those points that do not intersect with a polygon, we need to convert the polygons into points, by calculating centroids for them. These centroids can then be added to the "hcare" points data.

####### POLYGONS
# Get the polygons from the main data
polys <- yrk_hcare$osm_polygons

# Find out if there are any polygons that intersect with each other
int1 <- st_intersects(polys$geometry, polys$geometry)
# Take the count data and return T or F if the number of intersections is == 0
int1_bool <- lapply(int1, length) == 0

# Add the centroids to the polys dataframe
polys$centroid <- st_centroid(polys$geometry)

####### MULTIPOLYGONS
mpolys <- yrk_hcare$osm_multipolygons
# Add the centroids to the polys dataframe
mpolys$centroid <- st_centroid(mpolys$geometry)

mpolys <- st_drop_geometry(mpolys)


####### COMBINE THE REQUIRED COLUMNS FROM THE POINTS THAT ARE LEFT
polys <- st_drop_geometry(polys)
polys <- polys  |>  
  rename(geometry = centroid)

mpolys <- mpolys  |>  
  rename(geometry = centroid)


y_hcare_points <- bind_rows(
  select(hcare_points, osm_id, amenity, geometry),
  select(polys, osm_id, amenity, geometry),
  select(mpolys, osm_id, amenity, geometry)
)

y_hcare_points <- y_hcare_points[!is.na(y_hcare_points$amenity), ]

tmap_mode("view")
qtm(y_hcare_points)
tmap_mode("plot")
# Save y_hcare_points

# saveRDS(y_hcare_points, "Data/y_hcare_points.RDS")

# remove(hcare_query, hcare_vars, int1, mpolys, polys,
#        hcare_points, yrk_hcare, int1_bool)
```

# Exploratory data analysis

The cleaned data was then plotted so that we could make sure that both the numerical counts of the different amenities looked feasible, and also the spatial distribution of them was correctly within the study area. This can be see in @fig-hcare. \FloatBarrier

```{r fig-hcare, fig.cap="Healthcare services in York", echo=FALSE, message=FALSE}
y_hcare_points <- readRDS("Data/y_hcare_points.RDS")
##| label: fig-hcare
##| fig-cap: Healthcare services in the York study area
## | fig-asp: 0.618
## | fig-width: 18
## | fig-pos: H
# y_hcare_points <- readRDS("Data/y_hcare_points.RDS")
p1 <- ggplot(y_hcare_points, aes(x = amenity, fill = amenity)) +
  geom_bar() +
  scale_fill_brewer(palette = "Set2") +
  labs(x = "Amenity type", y = "Amenity count") +
  guides(fill = "none") +
  theme(axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9),
        axis.text.x = element_text(size = 7))

p2 <- ggplot(data = y_hcare_points) +
  annotation_map_tile("osm", zoomin = -1) +
  geom_sf(aes(col = amenity)) +
  scale_color_brewer(palette = "Set2") +
  theme_void()

p <- grid.arrange(p1, p2, nrow = 1)
```

\FloatBarrier

# Methodology

## Isochrone calculation

Once the data had been prepared, 20-minute walking time isochrones were calculated around each of the healthcare points. This was carried out using the `opentripplanner::otp_isochrone` function. Isochrones were used because we did not want routes to be calculated for origins that were further away than this walking distance. If isochrones were not used, routes would have been calculated to destinations that would not need to be accessed because they were further away than the closest, which would end up skewing the results of the circuity calculations, and provided no benefit to analysing access.

```{r, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE, eval=FALSE}
# Calculate an isochrone for each row in y_hcare_points and save the results to a new dataframe

# y_hcare_points is a data frame with 128 rows
# num_rows <- min(nrow(y_hcare_points), 128)  # Ensure we don't go beyond the number of rows in y_hcare_points or 128, whichever is smaller

# Create the new dataframe to store the results in
y_hcare_isos <- data.frame()

# # Loop through the points data calculating isochrones for each row.
for (i in 1:nrow(y_hcare_points)) {
  a <- y_hcare_points[i, ]
  a <- cbind(a,
              otp_isochrone(otpcon = otpcon,
                            fromPlace = a,
                            mode = "walk",
                            maxWalkDistance = 1600,
                            cutoffSec = 1200))
y_hcare_isos <- rbind(y_hcare_isos, a)
}

remove(a)
remove(i)

# rename the geometry.1 column
y_hcare_isos <- y_hcare_isos |>
  rename(isochrone = geometry.1)

# # Remove the fromPlace column
y_hcare_isos <- y_hcare_isos |>
  select(-fromPlace)

# saveRDS(y_hcare_isos, "Data/y_hcare_isos.RDS")

# # Test this to see if it worked
tmap_mode("view")
qtm(y_hcare_isos$geometry) +
  qtm(y_hcare_isos$isochrone, fill = NULL)
tmap_mode("plot")
```

```{r, echo=FALSE, include=FALSE, eval=FALSE}
y_hcare_isos <- readRDS("Data/y_hcare_isos.RDS")
```

## Make the hex grid

It was decided that points fo origin would be created so they act as a proxy for exact origin locations. One of the alternatives would have been to use Output Area (OA) population weighted centroids. This would however have meant that it would have resulted in a single origin location for each OA. Postcodes could have also been used, but this would have resulted in more processing power being required (something that is limited at this time), so the most effective solution was to calculate a hexagonal grid using `st_make_grid` from the `sf` package, with a `cellsize` of 250 (units). The grid was then transformed from polygons to points/centroids (so 7 in total for each hexagon). Duplicate points for those neighbouring polygons were then removed and the final point data was then ready for calculating routes from.

```{r, echo = FALSE, message=FALSE, warning=FALSE, include=FALSE, eval=FALSE}
bbox <- st_bbox(y_lad)
hex_grid <- st_make_grid(bbox,
                         cellsize = 250,
                         square = FALSE
                         )
# saveRDS(hex_grid, "Data/hex_grid.RDS")
# remove(bbox)

# tmap_mode("view")
# qtm(hex_grid, fill = NULL)
# tmap_mode("plot")
```

```{r, include=FALSE, include=FALSE, eval=FALSE, echo=FALSE}
hex_grid <- readRDS("Data/hex_grid.RDS")
```

```{r, echo=FALSE, include=FALSE, eval=FALSE, warning=FALSE}
# Convert the sfc to an sf
hex_sf <- st_as_sf(hex_grid)

# Now calculate the centroids
hex_centroids <- st_centroid(hex_sf)

# Now cast hex_sf$x as points to a new df
hex_points <- st_cast(hex_sf$x, "POINT")

# Now convert to sfc_points to an sf
hex_points <- st_as_sf(hex_points)

# Remove duplicate points
hex_points <- unique(hex_points)
# remove(hex_sf, hex_grid)
saveRDS(hex_centroids, "Data/hex_centroids.RDS")
saveRDS(hex_points, "Data/hex_points.RDS")
# remove(hex_centroids, hex_points)
# All points required have now been produced.
# Next, clip the points data so that only points that appear within each isochrone remain
tmap_mode("view")
qtm(hex_centroids, dots.col = "red") +
  qtm(hex_points, dots.col = "pink")
tmap_mode("plot")

```

```{r, include=FALSE, eval=FALSE, echo=FALSE}
hex_centroids <- readRDS("Data/hex_centroids.RDS")
hex_points <- readRDS("Data/hex_points.RDS")
```

```{r, echo=FALSE, include=FALSE, eval=FALSE}
# ... Clip the hex points/centroids so that we are left with only the ones that fall within the hcare isochrones 

y_hcare_isos
y_hcare_isos <- st_transform(y_hcare_isos, 27700)
y_hcare_isos

y_hcare_isos <- y_hcare_isos |> 
    st_set_geometry('isochrone')
y_hcare_isos
y_hcare_isos <- st_transform(y_hcare_isos, 27700)
y_hcare_isos

hexcents_inhcareisos <- st_intersection(hex_centroids, y_hcare_isos$isochrone)
hexpoint_inhcareisos <- st_intersection(hex_points, y_hcare_isos$isochrone)

saveRDS(hexcents_inhcareisos, "Data/hexcents_inhcareisos.RDS")
saveRDS(hexpoint_inhcareisos, "Data/hexpoint_inhcareisos.RDS")
remove(hexcents_inhcareisos, hexpoint_inhcareisos)

tmap_mode("view")
qtm(hexpoint_inhcareisos, dots.col = "pink") +
  qtm(hexcents_inhcareisos, dots.col = "red") +
  qtm(y_hcare_isos$isochrone, fill = NULL)
tmap_mode("plot")
```

```{r, include=FALSE, echo=FALSE, eval=FALSE}
hexcents_inhcareisos <- readRDS("Data/hexcents_inhcareisos.RDS")
hexpoint_inhcareisos <- readRDS("Data/hexpoint_inhcareisos.RDS")
```

## Calculating routes & circuity

Once the point data was clipped to the isochrones, routes were calculated from each point within each isochrone to the relevant amenity destination. This was done using the `opentripplanner::otp_plan` function using `walk` as the only valid method of transit.

Circuity was then calculated for each route using the following formula: -

$$
k_{ij} = \frac{(l_{ij} - d_{ij})}{l_{ij}}
$$

Where $k_{ij}$ is the circuity, $l$ is the route distance between node $i$ to node $j$, and $d$ is the geometric distance between node $i$ and node $j$. The resulting measurement will be between 0 and 1, with the least circuitous (straightest) routes being closer to 0 and the most circuitous routes being closer to 1.

```{r, echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE, include=FALSE}
# Use each of the hex centroids as the START location & the 126 hcare_points as the END location.
# If a hex_centroid appears in an hcare_isochrone, calculate walking time from that hex POINT/CENT TO hcare POINT.

# y_hcare_isos
y_hcare_isos <- st_transform(y_hcare_isos, 4326)
# y_hcare_isos

# hexcents_inhcareisos
hexcents_inhcareisos <- st_transform(hexcents_inhcareisos, 4326)
# hexcents_inhcareisos

# Create a blank sf object to hold the results
hcare_hexcent_routes <- st_sf(geometry = st_sfc(st_point()), crs = 4326)
# Delete the rows from the newly created object
hcare_hexcent_routes <- hcare_hexcent_routes[-1, ]

# i=0
# i=i+1
# Run through the y_hcare_isos getting the routes to each hcare point from each hex_centroid that appears within that isocrone
for (i in 1:nrow(y_hcare_isos)) {
  
  y_hcare_isos <- st_set_geometry(y_hcare_isos, "isochrone")
  # See which hex_cents are in the (i) hcare isochrone
  from_hex_cent <- st_intersection(hexcents_inhcareisos, y_hcare_isos[i, ])
  # Remove duplicate points from from_hex_cent
  from_hex_cent <- unique(from_hex_cent)

  # Start calculating walking routes data
  # Set the geometry column of y_hcare_isos
  y_hcare_isos <- st_set_geometry(y_hcare_isos, "geometry")
  y_hcare_isos <- st_transform(y_hcare_isos, 4326)
  
# j=0
# j=j+1
  # Loop through each hex point calculating the walking distance to the y_hcare_isos point
  for (j in 1:nrow(from_hex_cent)) {
    # get the from place from from_hex_cent
    f <- st_as_sf(from_hex_cent$x[j])
    
    # get the to place
    t <- st_as_sf(y_hcare_isos$geometry[i])
    
    # get the fromID
    # a <- as.character(from_hex_cent[j,])
# Use tryCatch to handle errors
    tryCatch({
      # Attempt to calculate the route
      r <- otp_plan(otpcon = otpcon,
                    fromPlace = f,
                    toPlace = t,
                    mode = "walk",
                    get_geometry = TRUE
                    )
      # If a route is found, rbind the result to the hcare_hexcent_routes
      m <- cbind(r, f, t)
      hcare_hexcent_routes <- rbind(hcare_hexcent_routes, m)
    }, error = function(e) {
      # Print error message
      message("Error occurred: ", conditionMessage(e))
      # Exit the tryCatch block
      return(NULL)
    })
    print(paste(j,"of",nrow(from_hex_cent),"done","&",i,"of",nrow(y_hcare_isos), "done"))
  }
}
# rename x to "from", and x.1 to "to"
hcare_hexcent_routes <- rename(hcare_hexcent_routes, from = x)
hcare_hexcent_routes <- rename(hcare_hexcent_routes, to = x.1)
# delete the fromPlace and toPlace columns
hcare_hexcent_routes <- hcare_hexcent_routes |> 
  select(-fromPlace)
hcare_hexcent_routes <- hcare_hexcent_routes |> 
  select(-toPlace)
# drop the linestring (geometry) column
# hcare_hexcent_routes <- st_drop_geometry(hcare_hexcent_routes)
# hcare_hexcent_routes
```

```{r, echo=FALSE, eval=FALSE, include=FALSE}
saveRDS(hcare_hexcent_routes, "Data/hcare_hexcent_routes.RDS")
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
hcare_hexcent_routes <- readRDS("Data/hcare_hexcent_routes.RDS")
```

```{r, echo=FALSE, eval=FALSE, include=FALSE}
# Create an index for the hcare_hexcent_routes data
# Add index column
hcare_hexcent_routes$index <- row.names(hcare_hexcent_routes)

# Move index column to the first position
hcare_hexcent_routes <- hcare_hexcent_routes |>  
  select(index, everything())

# Print the modified data frame
hcare_hexcent_routes[1:5,]
saveRDS(hcare_hexcent_routes, "Data/hcare_hexcent_routes.RDS")

# tmap_mode("view")
# qtm(hcare_hexcent_routes$from, dots.col = "green") +
#   qtm(hcare_hexcent_routes$to, dots.col = "red")
# tmap_mode("plot")
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
hcare_hexcent_routes <- readRDS("Data/hcare_hexcent_routes.RDS")
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
# convert hcare_hexcent_routes to sf
hcare_hexcent_routes <- st_as_sf(hcare_hexcent_routes)
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
# from_place <- readRDS("Data/from_place.RDS")
# to_place <- readRDS("Data/to_place.RDS")
```

```{r, echo=FALSE, include=FALSE, eval=FALSE}
##############################################################################################
# Calculate circuity for each route
##############################################################################################
# a <- st_drop_geometry(hcare_hexcent_routes)
# from_place <- st_transform(from_place, crs = 4326)
# to_place <- st_transform(to_place, crs = 4326)

# i = 6549
# i = i + 1

# Initialize a vector to store the distances
# distances <- numeric(nrow(a))
hcare_hexcent_routes$circuity <- ""
# Loop through each row
for (i in 1:nrow(hcare_hexcent_routes)) {
  # Print the POINT geometries for debugging
  # print(hcare_hexcent_routes$from)
  # print(hcare_hexcent_routes$to)
  # Calculate euclidean distance
  e <- as.numeric(st_distance(hcare_hexcent_routes$from[i], hcare_hexcent_routes$to[i]))
  c <- ((hcare_hexcent_routes$walkDistance[i] - e) / hcare_hexcent_routes$walkDistance[i])
  hcare_hexcent_routes[i,34] <- round(c,2)
  print(paste(i,"of",nrow(hcare_hexcent_routes),"done"))
}
# if there are negative values, make them 0
sum(hcare_hexcent_routes$circuity == 0)
 # Assign the distances to a column in dataframe 'a'
# a$euclidean_distance <- distances
# c <- as.numeric(drop_na(as.data.frame(st_drop_geometry((as.numeric(a[i,9])) - as.numeric(e)) / st_drop_geometry(as.numeric(a[i,9])))))
saveRDS(hcare_hexcent_routes, "Data/hcare_hexcent_routes.RDS")
remove(c,e,f,i,j,m,r,t)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE, include=FALSE}
# Use each of the hex centroids as the START location & the 126 hcare_points as the END location.
# If a hex_centroid appears in an hcare_isochrone, calculate walking time from that hex POINT/CENT TO hcare POINT.

# y_hcare_isos
y_hcare_isos <- st_transform(y_hcare_isos, 4326)
# y_hcare_isos

# hexpoint_inhcareisos
hexpoint_inhcareisos <- st_transform(hexpoint_inhcareisos, 4326)
# hexcents_inhcareisos

# Create a blank sf object to hold the results
hcare_hexpoint_routes <- st_sf(geometry = st_sfc(st_point()), crs = 4326)
# Delete the rows from the newly created object
hcare_hexpoint_routes <- hcare_hexpoint_routes[-1, ]

# i=0
# i=i+1
# Run through the y_hcare_isos getting the routes to each hcare point from each hex_centroid that appears within that isocrone
for (i in 1:nrow(y_hcare_isos)) {
  
  y_hcare_isos <- st_set_geometry(y_hcare_isos, "isochrone")
  # See which hex_cents are in the (i) hcare isochrone
  from_hex_point <- st_intersection(hexpoint_inhcareisos, y_hcare_isos[i, ])
  # Remove duplicate points from from_hex_cent
  from_hex_point <- unique(from_hex_point)

  # Start calculating walking routes data
  # Set the geometry column of y_hcare_isos
  y_hcare_isos <- st_set_geometry(y_hcare_isos, "geometry")
  y_hcare_isos <- st_transform(y_hcare_isos, 4326)
  
# j=0
# j=j+1
# Loop through each hex point calculating the walking distance to the y_hcare_isos point
  for (j in 1:nrow(from_hex_point)) {
    # get the from place from from_hex_cent
    f <- st_as_sf(from_hex_point$x[j])
    
    # get the to place
    t <- st_as_sf(y_hcare_isos$geometry[i])
    
    # get the fromID
    # a <- as.character(from_hex_cent[j,])
# Use tryCatch to handle errors
    tryCatch({
      # Attempt to calculate the route
      r <- otp_plan(otpcon = otpcon,
                    fromPlace = f,
                    toPlace = t,
                    mode = "walk",
                    get_geometry = TRUE
                    )
      # If a route is found, rbind the result to the hcare_hexcent_routes
      m <- cbind(r, f, t)
      hcare_hexpoint_routes <- rbind(hcare_hexpoint_routes, m)
    }, error = function(e) {
      # Print error message
      message("Error occurred: ", conditionMessage(e))
      # Exit the tryCatch block
      return(NULL)
    })
    print(paste(j,"of",nrow(from_hex_point),"done","&",i,"of",nrow(y_hcare_isos), "done"))
  }
}

# rename x to "from", and x.1 to "to"
hcare_hexpoint_routes <- rename(hcare_hexpoint_routes, from = x)
hcare_hexpoint_routes <- rename(hcare_hexpoint_routes, to = x.1)
# delete the fromPlace and toPlace columns
hcare_hexpoint_routes <- hcare_hexpoint_routes |> 
  select(-fromPlace)
hcare_hexpoint_routes <- hcare_hexpoint_routes |> 
  select(-toPlace)
# drop the linestring (geometry) column
# hcare_hexpoint_routes <- st_drop_geometry(hcare_hexpoint_routes)
# hcare_hexpoint_routes
```

```{r, echo=FALSE, eval=FALSE, include=FALSE}
saveRDS(hcare_hexpoint_routes, "Data/hcare_hexpoint_routes.RDS")
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
hcare_hexpoint_routes <- readRDS("Data/hcare_hexpoint_routes.RDS")
```

```{r, echo=FALSE, include=FALSE, eval=FALSE}
# Create an index for the hcare_hexcent_routes data
# Add index column
hcare_hexpoint_routes$index <- row.names(hcare_hexpoint_routes)

# Move index column to the first position
hcare_hexpoint_routes <- hcare_hexpoint_routes |>  
  select(index, everything())

# Print the modified data frame
saveRDS(hcare_hexpoint_routes, "Data/hcare_hexpoint_routes.RDS")

tmap_mode("view")
qtm(hcare_hexcent_routes$from, dots.col = "green") +
  qtm(hcare_hexcent_routes$to, dots.col = "red")
tmap_mode("plot")
```

```{r, echo=FALSE, include=FALSE, eval=FALSE}
hcare_hexcent_routes <- readRDS("Data/hcare_hexcent_routes.RDS")
```

```{r, echo=FALSE, include=FALSE, eval=FALSE}
# convert hcare_hexcent_routes to sf
hcare_hexpoint_routes <- st_as_sf(hcare_hexpoint_routes)
```

```{r, echo=FALSE, include=FALSE, eval=FALSE, message=FALSE}
##############################################################################################
# Calculate circuity for each route
##############################################################################################
# hcare_hexpoint_routes <- st_as_sf(hcare_hexpoint_routes)
# hcare_hexpoint_routes <- as.data.frame(hcare_hexpoint_routes)
# i = 0
# i = i + 1

# Initialize a vector to store the distances
# distances <- numeric(nrow(a))
hcare_hexpoint_routes$circuity <- ""
# Loop through each row
for (i in 1:nrow(hcare_hexpoint_routes)) {
  # Print the POINT geometries for debugging
  # print(hcare_hexcent_routes$from)
  # print(hcare_hexcent_routes$to)
  # Calculate euclidean distance
  e <- as.numeric(st_distance(hcare_hexpoint_routes$from[i], hcare_hexpoint_routes$to[i]))
  c <- ((hcare_hexpoint_routes$walkDistance[i] - e) / hcare_hexpoint_routes$walkDistance[i])
  hcare_hexpoint_routes[i,32] <- round(c,2)
  print(paste(i,"of",nrow(hcare_hexpoint_routes),"done"))
}
# if there are negative values, make them 0
# sum(hcare_hexpoint_routes$circuity == 0)
 # Assign the distances to a column in dataframe 'a'
# a$euclidean_distance <- distances
# c <- as.numeric(drop_na(as.data.frame(st_drop_geometry((as.numeric(a[i,9])) - as.numeric(e)) / st_drop_geometry(as.numeric(a[i,9])))))
# Print the modified data frame
saveRDS(hcare_hexpoint_routes, "Data/hcare_hexpoint_routes.RDS")
```

```{r, echo=FALSE, include=FALSE, eval=FALSE}
hcare_hexpoint_routes <- readRDS("Data/hcare_hexpoint_routes.RDS")
```

```{r, message=FALSE, echo=FALSE, include=FALSE, eval=FALSE}
# Refresh the environment ready to start work on the amenities
remove(c, e, f, i, j, m, r, t, y_hcare_isos, y_hcare_points, hexpoint_inhcareisos, from_hex_point, hcare_hexpoint_routes, hcare_hexcent_routes)
```

```{r, include=FALSE, eval=FALSE, echo=FALSE}
hcare_hexcent_routes <- readRDS("Data/hcare_hexcent_routes.RDS")
hcare_hexpoint_routes <- readRDS("Data/hcare_hexpoint_routes.RDS")
```

```{r, include=FALSE, eval=FALSE, echo=FALSE}
hcare_hexcent_routes <- st_set_geometry(hcare_hexcent_routes, value = "from")
hcare_hexcent_routes # = WGS 84
hcare_hexpoint_routes <- st_set_geometry(hcare_hexpoint_routes, value = "from")
hcare_hexpoint_routes # = WGS 84
```

## Output Areas

```{r, eval=FALSE, include=FALSE, echo=FALSE}
# Read in the OA shapefile
oas <- st_read("Data/York_oas.shp")
# remove(oas)
oas <- st_transform(oas, crs = 4326)
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
oas <- st_as_sf(oas[,c(2, 7)])
oas
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
# Merge the hcare cents and points data into a single dataframe
hcare_all <- readRDS("Data/hcare_all.RDS")
hcare_hexcent_routes <- readRDS("Data/hcare_hexcent_routes.RDS")
hcare_hexpoint_routes <- readRDS("Data/hcare_hexpoint_routes.RDS")
hcare_all <- rbind(hcare_hexcent_routes, hcare_hexpoint_routes)
```

```{r, include=FALSE, echo=FALSE, eval=FALSE}
oas <- readRDS("Data/y_oas.RDS")
# Add the OACode to the hcare_all data
# Check that the crs are correct
oas # = WGS 84
oas <- st_transform(oas, 4326)
oas # = WGS 84 | geometry = geometry
hcare_all # = WGS 84 | geometry = from

# Find which "from" points intersect with the y_oas$geometry
oa_intersects <- hcare_all |> st_intersects(oas)

# Apply the vapply function to the oa_intersects results so that the OACode is added to the hcare_all data
hcare_all$oa <- vapply(oa_intersects,
                       function(index) {if(length(index)==0) {
                         NA_character_} else {
                               oas$OA21CD[index]
                             }
                           },
                           character(1))
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
remove(oa_intersects, y_oas, hcare_hexcent_routes, hcare_hexpoint_routes)
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
saveRDS(hcare_all, "Data/hcare_all.RDS")
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
hcare_all <- readRDS("Data/hcare_all.RDS")
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
# reindex all the hcare_all data and add the index to a new column
hcare_all <- as.data.frame(hcare_all)
hcare_all$index <- row.names(hcare_all)
hcare_all <- as.data.frame(hcare_all)
# take the "from" and "to" columns and put them in a new dataframe
from_to <- hcare_all[,c("index", "oa" , "from", "to", "walkDistance", "geometry")]
from_to <- st_as_sf(from_to)
from_to
hcare_all <- st_as_sf(hcare_all)
hcare_all
# saveRDS(hcare_all, "Data/hcare_all.RDS")
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
saveRDS(from_to, "Data/from_to.RDS")
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
# Calculate the straight line distance between the from and to points 
from_to$e <- st_distance(from_to$from,
                         from_to$to,
                         which = "Great Circle",
                         by_element = TRUE)

saveRDS(from_to, "Data/from_to.RDS")
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
from_to <- from_to  |>  
  rename(OA21CD = oa)
# Convert from_to$e to numeric
from_to$e <- as.numeric(from_to$e)
# Calculate the circuity of each route
from_to$circuity <- ((from_to$walkDistance - from_to$e)/from_to$walkDistance)
saveRDS(from_to, "Data/from_to.RDS")
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
from_to <- readRDS("Data/from_to.RDS")
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
# create a new dataframe containing the mean circuity for each OA21CD from the from_to dataframe
# Drop the negative circuity values
from_to <- from_to[from_to$circuity >= 0, ]
saveRDS(from_to, "Data/from_to.RDS")
# calculate circuity means
circuity <- as.data.frame(st_drop_geometry(group_by(from_to, OA21CD) |>
  summarise(mean_circuity = mean(circuity, na.rm = FALSE))))
saveRDS(circuity, "Data/circuity.RDS")
```

```{r, eval=FALSE, include=FALSE, echo=FALSE}
oas <- readRDS("Data/y_oas.RDS")
oas <- as.data.frame(oas)
oa_circuity <- merge(oas, circuity, by = "OA21CD")
oa_circuity <- st_as_sf(oa_circuity)
oa_circuity <- oa_circuity[c("OA21CD", "mean_circuity", "geometry")]
saveRDS(oa_circuity, "Data/oa_circuity.RDS")
```

Output areas were then loaded and the origins that intersect with each were calculated. The mean circuity for each OA to provide the final results for the study area. These were then plotted and can be seen in @fig-ycircuity.

# Results

@fig-ycircuity shows the spatial distribution of the mean circuity for each OA in York. We can see a number of places with relatively high circuity; one area in the south and one in the north-east and the OAs with the lowest circuity seems to be mainly in the east, with a small area around Haxby in the north displaying particularly a low mean circuity. This however does not show the numeric distribution of the mean values, so a histogram was produced to visualise this.

\FloatBarrier

```{r fig-ycircuity, fig.cap="Mean circuity of routes to healthcare services in York", message=FALSE, echo=FALSE}
oa_circuity <- readRDS("Data/oa_circuity.RDS")
ggplot() +
  annotation_map_tile("osm", zoomin = -1) +
  geom_sf(data = oa_circuity,
          aes(fill = mean_circuity),
          color = NA) +
  scale_fill_viridis_c(alpha = 0.75)
```

```{=tex}
\FloatBarrier
\newpage
```

As we can see in @fig-circ_dist the histogram shows that distribution displays a small right-skew. The box-plot allows us to see this distribution more clearly, with the interquartile range (IQR) between around 0.23 and 3.0, and the median around 0.25. The upper and lower limits are around 0.42 and 0.12 respectively, and outliers at either end. This is a good sign in terms of access to healthcare services as it shows that the majority of the circuity values are relatively low, equating to a fairly low circuity overall in York. I will be concentrating on the outliers mentioned above in order to understand possible reasons for the variation at either end of the spectrum of circuity.

\FloatBarrier

```{r fig-circ_dist, fig.cap="Distribution of mean circuity for York OA's", echo=FALSE}
oa_circuity <- readRDS("Data/oa_circuity.RDS")

h <- ggplot(oa_circuity, aes(x = mean_circuity)) + 
  geom_histogram(binwidth = 0.01,
                 colour = "darkorange",
                 fill = "paleturquoise4") +
  labs(x = "Mean Circuity", y = "OA Count") +
  theme(axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9),
        axis.text.x = element_text(size = 7))

b <- ggplot(oa_circuity, aes(mean_circuity))
c <- b + geom_boxplot(notch = T,
                      fill = "paleturquoise4",
                      colour = "darkorange",#
                      outlier.colour = "goldenrod4",
                      outlier.shape = 1) +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

eda <- grid.arrange(h, c, nrow = 1)
```

\FloatBarrier

```{r, message=FALSE, echo=FALSE, include=FALSE, eval = FALSE}
oa_circuity <- readRDS("Data/oa_circuity.RDS")
hcare_all <- readRDS("Data/hcare_all.RDS")
from_to <- readRDS("Data/from_to.RDS")
# Get the OA with the lowest mean circuity
oa_lowest_ci <- which.min(oa_circuity$mean_circuity)
lowest_c <- oa_circuity[oa_lowest_ci, ]
lowest_c <- as.data.frame(lowest_c)
remove(oa_lowest_ci)
# rename the oa column ready for merging
hcare_all <- as.data.frame(hcare_all)
hcare_all <- rename(hcare_all, OA21CD = oa)

lowest_routes <- merge(lowest_c,
                       hcare_all[c("index",
                                   "OA21CD",
                                   "from",
                                   "to",
                                   "geometry")],
                       by = "OA21CD", 
                       all.x = TRUE)

# rename the columns ready for merging
names(lowest_routes)
lowest_routes <- rename(lowest_routes, oa_boundary = geometry.x)
lowest_routes <- rename(lowest_routes, route = geometry.y)
names(lowest_routes)
saveRDS(lowest_routes, "Data/lowest_routes.RDS")

# get the circuity from the from_to data
lowest_routes <- merge(lowest_routes,
                       st_drop_geometry(from_to[c("index",
                                                  "walkDistance",
                                                  "circuity")]),
                       by = "index",
                       all.x = TRUE)

circl <- lowest_routes[c("index", "route", "circuity")]

circl <- st_as_sf(circl)

#################################################################
# Get the OA with the highest mean circuity
oa_highest_ci <- which.max(oa_circuity$mean_circuity)
highest_c <- oa_circuity[oa_highest_ci, ]
highest_c <- as.data.frame(highest_c)
remove(oa_highest_ci)
# rename the oa column ready for merging
# hcare_all <- as.data.frame(hcare_all)
# hcare_all <- rename(hcare_all, OA21CD = oa)

highest_routes <- merge(highest_c,
                       hcare_all[c("index",
                                   "OA21CD",
                                   "from",
                                   "to",
                                   "geometry")],
                       by = "OA21CD", 
                       all.x = TRUE)

# rename the columns ready for merging
names(highest_routes)
highest_routes <- rename(highest_routes, oa_boundary = geometry.x)
highest_routes <- rename(highest_routes, route = geometry.y)
names(highest_routes)
saveRDS(highest_routes, "Data/highest_routes.RDS")

# get the circuity from the from_to data
highest_routes <- merge(highest_routes,
                       st_drop_geometry(from_to[c("index",
                                                  "walkDistance",
                                                  "circuity")]),
                       by = "index",
                       all.x = TRUE)

circh <- highest_routes[c("index", "route", "circuity")]

circh <- st_as_sf(circh)

circhamen <- merge(circh, y_hcare_points, by = "index", all.x = TRUE)

saveRDS(circl, "Data/circl.RDS")
saveRDS(circh, "Data/circh.RDS")
saveRDS(lowest_routes, "Data/lowest_routes")
saveRDS(highest_routes, "Data/highest_routes")
```

\FloatBarrier

```{r}
# Join the walkDistance from the from_to to the circl using OA21CD 
circl <- as.data.frame(circl)
from_to <- as.data.frame(from_to)
circl <- merge(circl, from_to[c("index", "walkDistance")], by = "index", all.x = TRUE)

circh <- as.data.frame(circh)
circh <- merge(circh, from_to[c("index", "walkDistance")], by = "index", all.x = TRUE)


```

\FloatBarrier

```{r fig-lowc, fig.cap="OA routes with lowest mean circuity", fig.width=5, fig.height=5, echo=FALSE}
circl <- readRDS("Data/circl.RDS")
circh <- readRDS("Data/circh.RDS")
lowest_routes <- readRDS("Data/lowest_routes")
highest_routes <- readRDS("Data/highest_routes")
y_lad <- readRDS("Data/y_lad_sf.RDS")

r1 <- ggplot() +
  annotation_map_tile(type = "osm", zoomin = -1) +
  geom_sf(data = circl, aes(colour = circuity)) +
  scale_colour_viridis_c(option = "plasma", guide = "none") +
  geom_sf(data = lowest_routes$from, colour = "green") +
  geom_sf(data = lowest_routes$to, color = "red") +
  theme(axis.text = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "null"),
        plot.caption = element_text(hjust = 0, size = 8),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank()) +
  geom_sf(data = y_lad, fill = NA)

r3 <- ggplot() +
  annotation_map_tile(type = "osm", zoomin = -1, alpha = 0.5) +
  geom_sf(data = circl, aes(colour = circuity)) +
  scale_colour_viridis_c(option = "plasma") +
  geom_sf(data = lowest_routes$from, colour = "green") +
  geom_sf(data = lowest_routes$to, color = "red") +
  theme(axis.text = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "null"),
        plot.caption = element_text(hjust = 0, size = 8),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(caption = "a) OA with lowest circuity")
```

```{r fig-highc, fig.cap="OA routes with highest mean circuity", fig.width=5, fig.height=5, echo=FALSE}
circl <- readRDS("Data/circl.RDS")
circh <- readRDS("Data/circh.RDS")
lowest_routes <- readRDS("Data/lowest_routes")
highest_routes <- readRDS("Data/highest_routes")
y_lad <- readRDS("Data/y_lad_sf.RDS")
circl <- st_as_sf(circl)
circh <- st_as_sf(circh)

r2 <- ggplot() +
  annotation_map_tile(type = "osm", zoomin = -1) +
  geom_sf(data = circh, aes(colour = circuity)) +
  scale_colour_viridis_c(option = "plasma", guide = "none") +
  geom_sf(data = highest_routes$from, colour = "green") +
  geom_sf(data = highest_routes$to, color = "red") +
  theme(axis.text = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "null"),
        plot.caption = element_text(size = 8, hjust = 0),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank()) +
  geom_sf(data = y_lad, fill = NA)

r4 <- ggplot() +
  annotation_map_tile(type = "osm", zoomin = -1, alpha = 0.5) +
  geom_sf(data = circh, aes(colour = circuity)) +
  scale_colour_viridis_c(option = "plasma") +
  geom_sf(data = highest_routes$from, colour = "green") +
  geom_sf(data = highest_routes$to, color = "red") +
  theme(axis.text = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "null"),
        plot.caption = element_text(size = 8, hjust = 0),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank()) +
  labs(caption = "b) OA with highest circuity")

```

To better understand why these two outlier OAs, and the aggregated route circuity calculations, plots were created to visualise them. @fig-hlroutes clearly shows that the OA with the lowest circuity is in the village of Haxby to the north of York.

```{r fig-hlroutes, fig.cap="OAs with the lowest and highest mean circuity routes", echo = FALSE, message=FALSE}
r <- grid.arrange(r1, r2, r3, r4, nrow = 2, ncol = 2)
```

```{r}
# Determine the length of each data frame
len_circl <- nrow(circl)
len_circh <- nrow(circh)

# Create a data frame with the maximum length
max_len <- max(len_circl, len_circh)
combined_table <- data.frame(
  circl_walkDistance = ifelse(seq_len(max_len) <= len_circl, circl$walkDistance, NA),
  circh_walkDistance = ifelse(seq_len(max_len) <= len_circh, circh$walkDistance, NA)
)

# rename the headers
combined_table <- combined_table |> 
  rename(Lowest = circl_walkDistance)
combined_table <- combined_table |> 
  rename(Highest = circh_walkDistance)

combined_table$Lowest <- mean(combined_table$Lowest, na.rm = TRUE)
combined_table$Highest <- mean(combined_table$Highest, na.rm = TRUE)
# drop duplicates from combined_table
combined_table <- unique(combined_table)


# Display table using kable
kable(combined_table, caption = "Mean walk distance comparison", align = "c")
```


\FloatBarrier

# What are the demographics of the best areas?

# What does car ownership look like in these areas?

# Discussion

Rural locations have higher car use and ownership, so planning should put services in the most accessible place

This circuity implies that the structure of the village is such that services are centered around the high street, which itself consists of a single fairly straight road through the village. By contrast, the OA with the highest circuity was to the north-west of York and is overall more rural, and is less densely built up. The location of the service is important to the calculations here, because it sits away from the main street through the village of Stockton on the Forest. This means that the route to the service is longer and more circuitous than it would be if the service was located on the main street.

In retrospect i could have not used isochrones to calculate route circuity. I should have used all hexpoints and then aggregated over OAs because the way I did it means that some OAs that may only have a single amenity at the edge may sit outside the isochrone. I could have taken the travel time as an average. However, this would have resulted in routes to all amenities, so using a route to the closest amenity was the most practical way of measuring the access

Make sure to point out limitations of the method Could have used a crossings file to make routes shorter for people etc.

Also there are other factors like crossings that could shorten routes

Could have used population density measure to weiight circuity

\
\

# References

::: {#refs}
:::

# Appendix {.appendix}
